---
title: "Figure4"
author: "Devi Veytia"
date: "2023-12-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Figure description/overview

This figures shows the distribution of ORO types across coastal and marine systems

3 panels 	
a). Infographic of coastal land & built waterfronts (?) / coastal ocean / open ocean 		
b). ORO types vs. CIDs per system
c). ORO types vs. ecosystem types for coastal ocean only

*Key messages:*
1. Shift of ORO types across systems : Coastal land w. Societal adapatation, Coastal ocean w. Renewable energy (& Conservation), Open Ocean w. Mitigation

2. Shift of ecosystem types across OROs: Mangroves for CO2 removal, Coral reef for Conservation / Adapt:Nature, Mangrove / Seagrass for Conservation Adapt:Humans. 

# Set up

```{r load libraries}
library(dplyr)
library(dbplyr)
library(R.utils)
library(RSQLite)
library(ggplot2)
library(cowplot)
```


```{r Get the latest version of sqlite database and connect}

sqliteDir <- here::here("data/sqlite-databases")
sqliteFiles <- dir(sqliteDir)
sqliteVersions <- as.numeric(gsub(".sqlite","",substring(sqliteFiles, regexpr("_v", sqliteFiles) + 2)))
latestVersion <- sqliteFiles[which.max(sqliteVersions)]
dbcon <- RSQLite::dbConnect(RSQLite::SQLite(), file.path(sqliteDir, latestVersion), create=FALSE)
```


```{r import common aesthetics}
factor_aes <- readxl::read_excel(here::here("R/factor_aesthetics.xlsx"))

```


# Panel A: Infographic of coastal land & built waterfronts (?) / coastal ocean / open ocean

```{r read in svg image of infographic created in inkscape}
## Read in the infographic of the marine systems
fig4_A_Img <- magick::image_read(here::here("figures/inkscape/marineSystems.svg"))

# Plot of the svg infographic 
fig4_A_ggp <- ggdraw()+draw_image(fig4_A_Img, scale = 1)

fig4_A_ggp
```

# Panel B: Heatmap of ORO types vs. CIDs per system

```{r read in data for the plot - use only mean predictions}

## Access relevant tables

predRel <- tbl(dbcon, "pred_relevance") %>%
  filter(0.5 <= relevance_mean) %>%
  select(analysis_id)

predType <- tbl(dbcon, "pred_oro_type_long") %>%
  filter(0.5 <= mean) %>%
  select(analysis_id, oro_branch, oro_type) 

predMarSys <- tbl(dbcon, "pred_marine_system") %>%
  select(analysis_id, 
         `marine_system.land - mean_prediction`,
         `marine_system.coastal ocean - mean_prediction`,
         `marine_system.open-ocean - mean_prediction`) %>% 
  rename(land = `marine_system.land - mean_prediction`,
         coastal_ocean = `marine_system.coastal ocean - mean_prediction`,
         open_ocean = `marine_system.open-ocean - mean_prediction`) %>%
  collect()%>%
  reshape2::melt(id.vars = c("analysis_id"), variable.name = "marine_system", value.name = 'mean') %>%
  filter(0.5 <= mean) %>%
  select(-c(mean))

predThreat <- tbl(dbcon, "pred_climate_threat") %>%
  select(analysis_id,
         `climate_threat.Temperature - mean_prediction`,
         `climate_threat.SLR - mean_prediction`,
         `climate_threat.Extreme_weather - mean_prediction`) %>%
  rename(Temperature = `climate_threat.Temperature - mean_prediction`,
         SLR = `climate_threat.SLR - mean_prediction`,
         Extreme_weather = `climate_threat.Extreme_weather - mean_prediction`) %>%
  collect() %>%
  reshape2::melt(id.vars = c("analysis_id"), variable.name = "climate_threat", value.name = 'mean') %>%
  filter(0.5 <= mean) %>%
  select(-c(mean))
  


## Data joining and calculations
# Format into data frame where each row is a publication (unique analysis_id)

# Include only articles that have a prediction for ORO type AND marine system
marSysTypeThreatDf <- predRel %>%
  inner_join(predType, by="analysis_id") %>%
  collect() %>%
  inner_join(predMarSys, by="analysis_id")

# predictions for climate threat can be optional, because NA value will be classified as 'other'
# so use left_join to add in threats
marSysTypeThreatDf <- marSysTypeThreatDf %>%
  left_join(predThreat, by="analysis_id")

# Tabulate counts for the intersection of the different factors
marSysTypeThreatSums <- marSysTypeThreatDf %>%
  group_by(oro_branch, oro_type, marine_system, climate_threat) %>%
  summarise(n_articles = n())



## Factoring variables for plotting

# retrieve aesthetics for relevant factoring variables
typeAES <- factor_aes[which(factor_aes$variable == "oro_type"),]
typeAES <- typeAES[order(typeAES$order),]
marSysAES <- factor_aes[which(factor_aes$variable == "marine_system"),]
marSysAES <- marSysAES[order(marSysAES$order),]
threatAES <- factor_aes[which(factor_aes$variable == "climate_threat"),]
threatAES <- threatAES[order(threatAES$order),]
threatAES$level[which(threatAES$level == "NA")] <- NA

# use aesthetics to factor variables
marSysTypeThreatSums <- marSysTypeThreatSums %>%
  mutate(
    oro_type = factor(oro_type, levels = typeAES$level, labels = typeAES$label),
    marine_system = factor(marine_system, levels = marSysAES$level, labels = marSysAES$label),
    climate_threat = factor(climate_threat, levels = threatAES$level, labels = threatAES$label, exclude = NULL)
  )

```

Plot panel B with the breaks based on quantile

```{r plot panel B breaks based on quantile}
nDat <- marSysTypeThreatSums
nDat$n_articles[which(nDat$climate_threat == "Unidentified")] <- NA
naDat <- marSysTypeThreatSums %>%
            filter(climate_threat == "Unidentified") %>%
            rename(na_articles = n_articles)

# function to scale breaks between 0-1 for inputting values in scale fill stepsn function
range01 <- function(x){(x-min(x))/(max(x)-min(x))} 

# get quantile for climate threat and unidentified datasets separately to get breaks
# because they will be plotted on two different colour scales
breaksFill <- quantile(marSysTypeThreatSums$n_articles[marSysTypeThreatSums$climate_threat != "Unidentified"], na.rm=T) # get the quantile values
breaksFill <- signif(breaksFill, digits = 2) # cap at 2 signif
breaksFill <- round((breaksFill/10))*10 # round to the nearest 10
breaksFill <- unique(breaksFill) # if two quantiles are the same value remove
breaksFill[1] <- 0 # set min to 0

breaksNA <- quantile(naDat$na_articles[marSysTypeThreatSums$climate_threat != "Unidentified"], na.rm=T)
breaksNA <- signif(breaksNA, digits = 2) 
breaksNA <- round((breaksNA/10))*10 
breaksNA <- unique(breaksNA)
breaksNA[1] <- 0

# Plot
fig4_B_quantile_ggp <- ggplot(nDat, aes(x = climate_threat, y=oro_type))+
  facet_grid(vars(marine_system))+
  # Fill for all articles
  geom_tile(aes(fill = n_articles))+
  scale_fill_binned(name = "N articles", 
               type = "viridis",
               breaks = breaksFill, nice.breaks = FALSE,
               labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
               rescaler = scales::rescale,
               #values = range01(breaksFill),
               show.limits = TRUE, 
               limits = breaksFill[c(1, length(breaksFill))], 
               oob= scales::squish,
               na.value = "transparent",
               guide = guide_coloursteps(order = 1),
               position = "top")+ 
  
  # new fill scale for unidentified climate threats
  new_scale_fill()+
  geom_tile(data = naDat,
            aes(fill = na_articles))+
  scale_fill_stepsn(name = "N unidentified", 
                    breaks=breaksNA,
                    labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
                    colours = gray.colors(length(breaksNA)),
                    values = range01(breaksNA),
                    show.limits = TRUE, limits = breaksNA[c(1, length(breaksNA))],
                    na.value = "transparent", 
                    guide = guide_coloursteps(order = 2),
                    position = "bottom")+
  
  # other aesthetics
  labs(x="Climate impact driver")+ 
  scale_y_discrete(limits = rev)+

  theme_bw()+
  theme(
    axis.text.x = element_text(angle = 30, hjust=1, vjust=1),
    legend.position = "left",
    axis.title.y = element_blank(),
    legend.key.width = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm')
  )

fig4_B_quantile_ggp
```


plot panel B breaks based on even breaks - does not look great because data are not distributed evenly
```{r plot panel B breaks based on even breaks - does not look great, eval=FALSE}
nDat <- marSysTypeThreatSums
nDat$n_articles[which(nDat$climate_threat == "Unidentified")] <- NA
naDat <- marSysTypeThreatSums %>%
            filter(climate_threat == "Unidentified") %>%
            rename(na_articles = n_articles)



# get even but pretty breaks for each of the datasets
breaksFill <- seq(0, max(marSysTypeThreatSums$n_articles[marSysTypeThreatSums$climate_threat != "Unidentified"], na.rm=T), length.out = 5) # get the quantile values
breaksFill <- signif(breaksFill, digits = 2) # cap at 2 signif
breaksFill <- round((breaksFill/500))*500 # round to the nearest 100
breaksFill <- unique(breaksFill) # if two quantiles are the same value remove

breaksNA <- seq(0, max(naDat$na_articles[marSysTypeThreatSums$climate_threat != "Unidentified"], na.rm=T), length.out = 5)
breaksNA <- signif(breaksNA, digits = 2) 
breaksNA <- round((breaksNA/5000))*5000
breaksNA <- unique(breaksNA)


## Plot
fig4_B_even_ggp <- ggplot(nDat, aes(x = climate_threat, y=oro_type))+
  facet_grid(vars(marine_system))+
  # Fill for all articles
  geom_tile(aes(fill = n_articles))+
  # scale_fill_stepsn(name = "N articles", 
  #                   n.breaks = n_breaksFill, nice.breaks = TRUE,
  #                   labels = function(x) ifelse(1000 <= x, paste(signif(x/1000, digits=2), "k"), paste(x)),
  #                   colors = viridis::viridis(n_breaksFill),
  #                   values = seq(0,1, by=0.25),
  #                   show.limits = TRUE, limits = c(0, max(nDat$n_articles, na.rm = T)),
  #                   na.value = "transparent")+ 
  scale_fill_binned(name = "N articles", 
               type = "viridis",
               breaks = breaksFill, nice.breaks = FALSE,
               labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
               rescaler = scales::rescale,
               #values = range01(breaksFill),
               show.limits = TRUE, 
               limits = breaksFill[c(1, length(breaksFill))], 
               oob= scales::squish,
               na.value = "transparent",
               guide = guide_coloursteps(order = 1),
               position = "top")+ 
  
  # new fill scale
  new_scale_fill()+
  geom_tile(data = naDat,
            aes(fill = na_articles))+
  scale_fill_stepsn(name = "N unidentified", 
                    breaks=breaksNA,
                    labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
                    colours = gray.colors(length(breaksNA)),
                    values = range01(breaksNA),
                    show.limits = TRUE, limits = breaksNA[c(1, length(breaksNA))],
                    na.value = "transparent", 
                    guide = guide_coloursteps(order = 2),
                    position = "bottom")+
  
  # other aesthetics
  labs(x="Climate impact driver")+ 
  
  scale_y_discrete(limits = rev)+
  #coord_flip()+
  theme_bw()+
  theme(
    axis.text.x = element_text(angle = 30, hjust=1, vjust=1),
    legend.position = "left",
    axis.title.y = element_blank(),
    legend.key.width = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm')
  )

fig4_B_even_ggp
```

I feel like because the scales are so different between the panels, I will have to normalize by the number of articles in each oro type? Therfore to get 100%, need to sum up the values for that row across all the panels.

```{r plot panel B normalizing by oro type ie by row to make a percentage}
paneltotals <- marSysTypeThreatSums %>%
  group_by(oro_type) %>%
  summarise(total = sum(n_articles))

marSysTypeThreatSumsNorm <- marSysTypeThreatSums %>%
  left_join(paneltotals) %>%
  mutate(percent_articles = n_articles/total*100)

nDat <- marSysTypeThreatSumsNorm
nDat$percent_articles[which(nDat$climate_threat == "Unidentified")] <- NA
naDat <- marSysTypeThreatSumsNorm %>%
            filter(climate_threat == "Unidentified") %>%
            rename(na_articles = percent_articles)


# get even but pretty breaks for each of the datasets
breaksFill <- seq(0, max(marSysTypeThreatSumsNorm$percent_articles[marSysTypeThreatSumsNorm$climate_threat != "Unidentified"], na.rm=T), length.out = 10) # sequence even values across range
breaksFill <- signif(breaksFill, digits = 2) # cap at 2 signif
breaksFill <- round((breaksFill/5))*5 # round 
breaksFill <- unique(breaksFill) # if two quantiles are the same value remove

breaksNA <- seq(0, max(naDat$na_articles[marSysTypeThreatSums$climate_threat != "Unidentified"], na.rm=T), length.out = 5)
breaksNA <- signif(breaksNA, digits = 2) 
breaksNA <- round((breaksNA/5))*5
breaksNA <- unique(breaksNA)


## plot
fig4_B_percent_ggp <- ggplot(nDat, aes(x = climate_threat, y=oro_type))+
  facet_grid(vars(marine_system))+
  # Fill for all articles
  geom_tile(aes(fill = percent_articles))+
  # scale_fill_stepsn(name = "% articles", 
  #                   n.breaks = n_breaksFill, nice.breaks = TRUE,
  #                   labels = function(x){paste(x,"%")},
  #                   colors = viridis::viridis(n_breaksFill),
  #                   show.limits = TRUE, limits = c(0, max(nDat$percent_articles, na.rm = T)),
  #                   na.value = "transparent")+ 
  scale_fill_binned(name = "% articles/ORO", 
               type = "viridis",
               breaks = breaksFill, nice.breaks = FALSE,
               labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
               rescaler = scales::rescale,
               #values = range01(breaksFill),
               show.limits = TRUE, 
               limits = breaksFill[c(1, length(breaksFill))], 
               oob= scales::squish,
               na.value = "transparent",
               guide = guide_coloursteps(order = 1),
               position = "top")+ 
  
  # new fill scale
  new_scale_fill()+
  geom_tile(data = naDat,
            aes(fill = na_articles))+
  scale_fill_stepsn(name = "% unidentified/ORO", 
                    breaks=breaksNA,
                    labels = function(x) ifelse(1000 <= x, paste(x/1000, "k"), paste(x)),
                    colours = gray.colors(length(breaksNA)),
                    values = range01(breaksNA),
                    show.limits = TRUE, limits = breaksNA[c(1, length(breaksNA))],
                    na.value = "transparent", 
                    guide = guide_coloursteps(order = 2),
                    position = "bottom")+
  
  # other aesthetics
  labs(x="Climate impact driver")+ 
  
  scale_y_discrete(limits = rev)+
  #coord_flip()+
  theme_bw()+
  theme(
    axis.text.x = element_text(angle = 30, hjust=1, vjust=1),
    legend.position = "left",
    axis.title.y = element_blank(),
    legend.key.width = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm')
  )

fig4_B_percent_ggp
```


Still loses the idea of the gradient of changes in oro types across marine systems, so keep with the stacked bar plot? Include code here just in case
```{r old stacked bar plot version}
fig4_B_barplot_ggp <- ggplot(marSysTypeThreatSums, aes(y = oro_type, x=n_articles, fill = climate_threat))+
  facet_wrap(vars(marine_system), ncol=1, scales = "free")+
  geom_col(position = "stack")+
  labs(fill = "Climate impact\ndriver", x = "N articles")+ 
  # colour palette derived from the IBM design library colour blind safe palette
  # https://davidmathlogic.com/colorblind/#%23648FFF-%23785EF0-%23DC267F-%23FE6100-%23FFB000-%235E5C5E
  scale_fill_manual(values = threatAES$colour, breaks = threatAES$label, na.value = "transparent")+ 
  scale_y_discrete(limits = rev)+
  theme_bw()+
  theme(
    #axis.text.x = element_text(angle = 45, hjust=1, vjust=1)
    legend.position = "left",
    axis.title.y = element_blank()
  )

fig4_B_barplot_ggp
```


# Panel C: Heatmap of ORO types vs. ecosystem types and outcome for coastal ocean only

```{r get phylopics for ecosystem type}
pics <- dir(here::here("figures/phylopics/"))

# get mangrove
if(!("mangrove.svg" %in% pics)){
  mangrove_uuid <- rphylopic::get_uuid(name = "Rhizophora mangle", n=5)
  mangrove_img <- rphylopic::pick_phylopic(name = "Rhizophora mangle", n = 1)
  mangrove_img <- rphylopic::get_phylopic("bacc6a59-80d2-461c-92d4-83cabc91cc39")
  rphylopic::save_phylopic(img=mangrove_img,
                path = here::here("figures/phylopics/mangrove.svg"))
}


# Get coral
if(!("coral.svg" %in% pics)){
  coral_img <- rphylopic::get_phylopic("32eeaa29-2e90-40b5-92fb-eb8d7fcab9ab")
  rphylopic::save_phylopic(img = coral_img,
              path = here::here("figures/phylopics/coral.svg"))
}


# Get macroalgae
if(!("macroalgae.svg" %in% pics)){
  macro_img <- rphylopic::get_phylopic("9acf11fa-89dd-4a56-b3da-8665c406c6f5")
  rphylopic::save_phylopic(img = macro_img,
              path = here::here("figures/phylopics/macroalgae.svg"))
}


# get seagrass -- for some reason I had to download this directly from the website
#seagrass_img <- rphylopic::get_phylopic("2534e10f-ea8e-436e-a8c8-13ac045eb867")
#rphylopic::save_phylopic(img = seagrass_img,
#              path = here::here("figures/phylopics/seagrass.svg"))


library(magick)
marsh_ras <- as.raster(image_fill(image_read(here::here("figures/phylopics/saltmarsh.jpg")),'none'))
mangrove_ras <- as.raster(image_fill(image_read_svg(here::here("figures/phylopics/mangrove.svg")),'none'))
coral_ras <- as.raster(image_fill(image_read_svg(here::here("figures/phylopics/coral.svg")),'none'))
macro_ras <- as.raster(image_fill(image_read_svg(here::here("figures/phylopics/macroalgae.svg")),'none'))
seagrass_ras <- as.raster(image_fill(image_read_svg(here::here("figures/phylopics/seagrass.svg")),'none'))

```



```{r read in data for the plot - use only mean predictions}

## Access relevant tables
predRel <- tbl(dbcon, "pred_relevance") %>%
  filter(0.5 <= relevance_mean) %>%
  select(analysis_id)

predType <- tbl(dbcon, "pred_oro_type_long") %>%
  filter(0.5 <= mean) %>%
  select(analysis_id, oro_branch, oro_type) 

predMarSys <- tbl(dbcon, "pred_marine_system") %>%
  select(analysis_id, 
         `marine_system.land - mean_prediction`,
         `marine_system.coastal ocean - mean_prediction`,
         `marine_system.open-ocean - mean_prediction`) %>% 
  rename(land = `marine_system.land - mean_prediction`,
         coastal_ocean = `marine_system.coastal ocean - mean_prediction`,
         open_ocean = `marine_system.open-ocean - mean_prediction`) %>%
  collect()%>%
  reshape2::melt(id.vars = c("analysis_id"), variable.name = "marine_system", value.name = 'mean') %>%
  filter(0.5 <= mean) %>%
  select(-c(mean))

predEcoType <- tbl(dbcon, "pred_ecosystem_type") %>%
  select(analysis_id,
         `ecosystem_type.Salt_marsh - mean_prediction`,
         `ecosystem_type.Mangrove - mean_prediction`,
         `ecosystem_type.Coral_reef - mean_prediction`,
         `ecosystem_type.Seagrass - mean_prediction`) %>%
  rename(Salt_marsh = `ecosystem_type.Salt_marsh - mean_prediction`,
         Mangrove = `ecosystem_type.Mangrove - mean_prediction`,
         Coral_reef = `ecosystem_type.Coral_reef - mean_prediction`,
         Seagrass = `ecosystem_type.Seagrass - mean_prediction`) %>%
  collect() %>%
  reshape2::melt(id.vars = c("analysis_id"), variable.name = "ecosystem_type", value.name = 'mean') %>%
  filter(0.5 <= mean) %>%
  select(-c(mean))

# Outcomes
predMit <- tbl(dbcon, "pred_climate_mitigation") %>%
  select(analysis_id, `0 - relevance - mean_prediction`) %>%
  rename(climate_mitigation = `0 - relevance - mean_prediction`) %>%
  filter(0.5 <= climate_mitigation) %>%
  collect()

predAdapt <- tbl(dbcon, "pred_adapt_to_threat") %>%
  select(analysis_id,
         `adapt_to_threat.Human - mean_prediction`,
         `adapt_to_threat.Natural - mean_prediction`) %>%
  rename(Human = `adapt_to_threat.Human - mean_prediction`,
         Natural = `adapt_to_threat.Natural - mean_prediction`) %>%
  collect() 
  #reshape2::melt(id.vars = c("analysis_id"), variable.name = "adapt_to_threat", value.name = 'mean') %>%
  #filter(0.5 <= mean) 
  


## Data joining

# Format into data frame where each row is a publication (unique analysis_id)

# Include only articles that have a prediction for ORO type AND coastal marine system and ecosystem type
coastEcoTypeDf <- predRel %>%
  inner_join(predType, by="analysis_id") %>%
  collect() %>%
  inner_join(predMarSys, by="analysis_id") %>%
  filter(marine_system == "coastal_ocean") %>%
  inner_join(predEcoType, by="analysis_id")

# Use left_join to add outcomes
coastEcoTypeDf <- coastEcoTypeDf %>%
  left_join(predMit, by="analysis_id") %>%
  left_join(predAdapt, by="analysis_id")


## Factoring variables for plotting

# retrieve aesthetics for relevant factoring variables
typeAES <- factor_aes[which(factor_aes$variable == "oro_type"),]
typeAES <- typeAES[order(typeAES$order),]
ecoTypeAES <- factor_aes[which(factor_aes$variable == "ecosystem_type"),]
ecoTypeAES <- ecoTypeAES[order(ecoTypeAES$order),]
adaptAES <- factor_aes[which(factor_aes$variable == "adapt_to_threat"),]
adaptAES <- adaptAES[order(adaptAES$order),]


# use aesthetics to factor variables
coastEcoTypeDf <- coastEcoTypeDf %>%
  mutate(
    oro_type = factor(oro_type, levels = typeAES$level, labels = typeAES$label),
    ecosystem_type = factor(ecosystem_type, levels = ecoTypeAES$level, labels = ecoTypeAES$label)
  )



# Tabulate counts for the intersection of the different factors
library(tidyr)
mitigationSums <- coastEcoTypeDf %>%
  group_by(oro_branch, oro_type, ecosystem_type) %>%
  summarise(n_articles = sum(0.5 <= climate_mitigation, na.rm=T)) %>%
  complete(ecosystem_type, fill = list(n_articles = 0))

adaptationSums <- coastEcoTypeDf %>%
  group_by(oro_branch, oro_type, ecosystem_type) %>%
  summarise(Human = sum(0.5 <= Human, na.rm=T),
            Natural = sum(0.5 <= Natural, na.rm=T)) %>%
  complete(ecosystem_type, fill = list(n_articles = 0)) %>%
  reshape2::melt(measure.vars = c("Human","Natural"), 
                 variable.name = "adapt_to_threat", value.name = "n_articles") %>%
  mutate(adapt_to_threat = factor(adapt_to_threat, levels = adaptAES$level, labels = adaptAES$label))


# Normalise by number of articles per ORO to get a percent
# calculate number of unique articles per oro type
oroTotalsDF <- coastEcoTypeDf %>%
  filter(0.5 <= climate_mitigation |
           0.5 <= Human | 0.5 <= Natural) %>%
  group_by(oro_type) %>%
  summarise(total = n_distinct(analysis_id))

# divide sums by these totals to get a percent
mitigationSums <- mitigationSums %>%
  left_join(oroTotalsDF, by = "oro_type") %>%
  mutate(percent_articles = n_articles/total*100)

adaptationSums <- adaptationSums %>%
  left_join(oroTotalsDF, by = "oro_type") %>%
  mutate(percent_articles = n_articles/total*100)

```

Note that the totals for each oro type are:
```{r print oro totals for reference}
print(oroTotalsDF)
```


```{r plot panel C.i - Mitigation}
fig4_C_i <- ggplot(mitigationSums, aes(y=oro_type, x=ecosystem_type))+
  geom_tile(aes(fill = percent_articles))+
  scale_fill_gradient2(mid="white",high="#3182bd", midpoint = 0, guide = guide_coloursteps())+
  scale_y_discrete(limits=rev)+
  geom_hline(yintercept = c(0.5,2.5,4.5), col="black", linewidth=0.5)+
  annotation_raster(marsh_ras, 0.5, 1.5, -2, -0)+
  annotation_raster(mangrove_ras, 1.5, 2.5, -2, -0)+
  annotation_raster(seagrass_ras, 2.5, 3.5, -2, -0)+
  annotation_raster(coral_ras, 3.5, 4.5, -2, -0)+
  #annotation_raster(macro_ras, 3.5, 4.5, -2, -0)+
  coord_cartesian(ylim = c(-1.5, length(levels(mitigationSums$oro_type))), clip = 'off')+
  labs(
    x = "Ecosystem type", #y = "ORO type", 
    fill = "% articles",
    title = "i. Mitigation"
  )+
  theme_bw()+
  theme(
    #plot.margin = unit(c(0,0,0,0), "cm"),
    axis.title.y = element_blank(),
    panel.grid = element_blank(),
    legend.position = "bottom",
    axis.text.x = element_text(angle=45, vjust=1, hjust=1)
    #axis.title.x = element_text(vjust = -8)
  )

fig4_C_i

```


Notes 
- what marine system is predicted for salt marshes, because none in coastal subset
- Why are there a high number of coral reef papers and marine renewable energy predicted? Try all marine systems
- Change colours from viridis to greens and blues



# Write figure

```{r Write figure to pdf}

## Save file
pdf(file = here::here("figures/main/marineSystem-ORO-climateThreat_barplot.pdf"),
    width = 10, height = 5)
plot_grid(marineSysImg_ggp, marineSysOROThreat_ggp, rel_widths = c(1,1.5))
while (!is.null(dev.list())) dev.off()

```

