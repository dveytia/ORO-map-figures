---
title: "0_data_processing_for_ShinyApp"
author: "GaÃ«l Mariani"
date: "2024-03-24"
output: html_document
---

This RMD file will arrange all data necessary to build the ShinyApp

```{r load libraries}
library(dplyr)
library(dbplyr)
library(R.utils)
library(RSQLite)
library(countrycode)
```


# Add files to sqlite database

```{r Get the latest version of sqlite database}

sqliteDir <- here::here("data/sqlite-databases")
sqliteFiles <- dir(sqliteDir)
sqliteVersions <- as.numeric(gsub(".sqlite","",substring(sqliteFiles, regexpr("_v", sqliteFiles) + 2)))
latestVersion <- sqliteFiles[which.max(sqliteVersions)]
dbcon <- RSQLite::dbConnect(RSQLite::SQLite(), file.path(sqliteDir, latestVersion), create=FALSE)

```
# Gather data informations for each analysis ID
```{r}

## DEVI, YOU CAN ADD THE CODE HERE ##

# make a table with the following column names for each analysis_id please:
# analysis_id | ecosystem_time | marine_system | year | ORO_type | ORO_branch | method_type

# one thing to keep in mind is that for each variable, there are multiple labels, so you won't be able to have each row be a unique analysis_id like what you requested above. The naming convention for each column in <variable name>.<label name>

# So what I've done is formatted the table in wide format, and each column contains the mean prediction for each label, and you can melt it how you want using reshape2::melt.data.frame() depending on which variables you want to look at. Or you can melt the whole thing, but knowing then that each row will have duplicate analysis_ids


# Get all tables in wide format
predRel <- tbl(dbcon, "pred_relevance") 

uniquerefs <- tbl(dbcon, "uniquerefs")

predBranch <- tbl(dbcon, "pred_oro_branch") %>%
  rename(oro_branch.Mitigation = `oro_branch.Mitigation - mean_prediction`,
         oro_branch.Nature = `oro_branch.Nature - mean_prediction`,
         oro_branch.Societal = `oro_branch.Societal - mean_prediction`) %>%
  select(analysis_id, oro_branch.Mitigation, oro_branch.Nature, oro_branch.Societal)

predMitigation <- tbl(dbcon, "pred_oro_any_mitigation") %>%
  rename(`oro_type.Marine Renewable Energy` = `oro_any.M_Renewables - mean_prediction`,
         `oro_type.Increase Efficiency` = `oro_any.M_Increase_efficiency - mean_prediction`,
         `oro_type.CO2 removal or storage` = `oro_any.M_CO2_removal_or_storage - mean_prediction`)%>%
  select(analysis_id, `oro_type.Marine Renewable Energy`, 
         `oro_type.Increase Efficiency`,`oro_type.CO2 removal or storage`)

predNature <- tbl(dbcon, "pred_oro_any_nature") %>%
  rename(`oro_type.Conservation` = `oro_any.N_Conservation - mean_prediction`,
         `oro_type.Human assisted evolution` = `oro_any.N_Human_assisted_evolution - mean_prediction`) %>%
  select(analysis_id, `oro_type.Conservation`, `oro_type.Human assisted evolution`)

predSocietal <- tbl(dbcon, "pred_oro_any_societal") %>%
  rename(`oro_type.Socio-institutional` = `oro_any.SA_Socioinstitutional - mean_prediction`,
         `oro_type.Built infrastructure & technology` = `oro_any.SA_Built_infrastructure_and_technology - mean_prediction`) %>%
  select(analysis_id, `oro_type.Socio-institutional`, `oro_type.Built infrastructure & technology`)

predEcosys <- tbl(dbcon, "pred_ecosystem_type") %>%
  rename(`ecosystem_type.Salt marsh` = `ecosystem_type.Salt_marsh - upper_pred`, ## NOTE just for salt marsh use upper prediction boundary
         `ecosystem_type.Mangrove` = `ecosystem_type.Mangrove - mean_prediction`,
         `ecosystem_type.Coral reef` = `ecosystem_type.Coral_reef - mean_prediction`,
         `ecosystem_type.Seagrass` = `ecosystem_type.Seagrass - mean_prediction`)%>%
  select(analysis_id, `ecosystem_type.Salt marsh`, `ecosystem_type.Mangrove`, 
         `ecosystem_type.Coral reef`, `ecosystem_type.Seagrass`)

predMarSys <- tbl(dbcon, "pred_marine_system") %>%
  rename(`marine_system.Coastal land` = `marine_system.land - mean_prediction`,
         `marine_system.Coastal ocean` = `marine_system.coastal ocean - mean_prediction`,
         `marine_system.Open-ocean` = `marine_system.open-ocean - mean_prediction`) %>%
  select(analysis_id, `marine_system.Coastal land`, `marine_system.Coastal ocean`, 
         `marine_system.Open-ocean`)

predMethod <- tbl(dbcon, "pred_method_type") %>%
  rename(`method_type.Mathematical_predictionsimulation` = `method_type.Mathematical_predictionsimulation - mean_prediction`,
         `method_type.Social_primary` = `method_type.Social_primary - mean_prediction`,
         `method_type.Empirical` = `method_type.Empirical - mean_prediction`) %>%
  select(analysis_id, `method_type.Mathematical_predictionsimulation`, 
         `method_type.Social_primary`, `method_type.Empirical`)



## Combine into data frame (wide)

df <- predRel%>%
  # First subset to only the relevant articles and join with year meta data
  filter(0.5 <= relevance_mean) %>%
  select(analysis_id) %>%
  left_join(uniquerefs %>% select(analysis_id, year), by = "analysis_id") %>%
  # Then join with other predicted variables
  left_join(predBranch, by = "analysis_id") %>%
  left_join(predMitigation, by = "analysis_id") %>%
  left_join(predNature, by = "analysis_id") %>%
  left_join(predSocietal, by = "analysis_id") %>%
  left_join(predEcosys, by = "analysis_id") %>%
  left_join(predMarSys, by = "analysis_id") %>%
  left_join(predMethod, by = "analysis_id") %>%
  collect()


summary(df)


```


# First Author Affiliation data
```{r}

### ----- LOAD DATA
uniquerefs <- tbl(dbcon, "uniquerefs") # metadata on the unique references
pred_relevance <- tbl(dbcon, "pred_relevance")  # which articles are relevant to OROs
pred_oro_branch <- tbl(dbcon, "pred_oro_branch") # predictions for ORO branch
world_shp <- sf::read_sf(here::here("data", "external", "world_shp"))  # shape file of the world
countries_ls <- read.csv(file = here::here("data", "external", "list_of_countries", "sql-pays.csv"), sep = ";") |>  # Countries names
  dplyr::mutate(country = countrycode(sourcevar   = name_en,
                                      origin      = "country.name",
                                      destination = "country.name"),
                iso_code = countrycode(sourcevar   = country,
                                       origin      = "country.name",
                                       destination = "iso3c"))

  
### ----- LOAD FUNCTIONS -----
source(here::here("R", "functions_to_format.R")) # all functions needed to format data

### ----- FORMAT DATA 

  ## ---- Subset to relevant rows and get the affiliation
  oroAffiliations <- pred_oro_branch |> 
    left_join(pred_relevance, by = "analysis_id") |> 
    filter(0.5 <= relevance_mean) |> 
    left_join(uniquerefs |> mutate(year = as.numeric(year)), by = "analysis_id") |> 
    mutate(adaptation = ifelse(0.5 <= `oro_branch.Nature - mean_prediction` |
                                 0.5 <= `oro_branch.Societal - mean_prediction`,
                                 1, 0),
           mitigation = ifelse(0.5 <= `oro_branch.Mitigation - mean_prediction`, 1 ,0),
           ORO_type   = case_when(mitigation == 1 ~ "Mitigation",
                                  TRUE ~ "Adaptation")) |> 
    select(analysis_id, ORO_type, affiliation, year) |> 
    collect()
  
  ## ---- Extract the country of the first author for each relevant publications
  data_1stA_country <- extract_1stA_affiliation(data         = oroAffiliations, 
                                                countries_ls = countries_ls)
  
  ## ---- Select the wanted data
  data_1stA_country <- data_1stA_country$oroAff_1stA |> 
      dplyr::filter(!is.na(country_aff)) |> 
      dplyr::mutate(country_aff = countrycode(sourcevar   = country_aff,
                                              origin      = "country.name",
                                              destination = "country.name"),
                    iso_code = countrycode(sourcevar   = country_aff,
                                           origin      = "country.name",
                                           destination = "iso3c")) |>
      dplyr::group_by(country_aff, iso_code, year, ORO_type) |> 
      dplyr::summarise(Count_ORO = n()) 
  
  data_1stA_country_tot <- data_1stA_country |> 
    dplyr::group_by(country_aff, iso_code) |> 
    dplyr::summarise(Count_ORO = sum(Count_ORO, na.rm = TRUE))|>
    dplyr::ungroup() |> 
    tidyr::replace_na(list(Count_ORO = 0)) |> 
    dplyr::mutate(percentage = (Count_ORO/sum(Count_ORO))*100)
  
  
  # --- Format the shapefile of the world countries polygon and bind data
  sf::sf_use_s2(FALSE)
  world_shp <- format_shp_of_the_world(world_shp    = world_shp,
                                                   data_to_bind = data_1stA_country_tot,
                                                   PROJ         = sf::st_crs(world_shp)) |> 
    sf::st_transform(crs = 4326) |> 
    dplyr::group_by(country, iso_code) |> 
    dplyr::summarise(geometry = sf::st_union(geometry))
    # left_join(country_grp |>  select(-Country), by = "iso_code") |> 
    # select(-country_aff) |> 
    # rename(country_aff = country) |> 
    # mutate(group_land = case_when(group_land %in% c("Land-locked", "SIDS", "Coastal") ~ group_land,
    #                               !is.na(group_land) & NA2_DESCRI != country_aff ~ "Island",
    #                               is.na(group_land)  & NA2_DESCRI != country_aff ~ "Island",
    #                               is.na(group_land)  & NA2_DESCRI == country_aff ~ "Coastal"))
  
```

# Geoparsing data
```{r}
data_geoparsing <- get(load(here::here("data", "geoparsing", "tmp_clean.RData")))
```


# Datasource possibilities
```{r}
datasource_options <- c("Geoparsing", "First author affiliation")
```


# Years options
```{r}
year_values <- c(min(data_1stA_country$year, na.rm = TRUE), max(data_1stA_country$year, na.rm = TRUE))
```



# Save all objects

```{r}
save(data_1stA_country, world_shp, data_geoparsing, datasource_options, year_values, file = here::here("data", "data_for_ShinyApp.RData"))

save(data_1stA_country, world_shp, data_geoparsing, datasource_options, year_values, 
     file = here::here("../ShinyApp/ORO.app/data/data_for_ShinyApp.RData"))
```

